# Generated by the protocol buffer compiler.  DO NOT EDIT!
# Source: rpc.proto for package 'lnrpc'

require 'grpc'
require_relative 'rpc_pb'

module Lnrpc
  module WalletUnlocker
    # The WalletUnlocker service is used to set up a wallet password for
    # lnd at first startup, and unlock a previously set up wallet.
    class Service

      include GRPC::GenericService

      self.marshal_class_method = :encode
      self.unmarshal_class_method = :decode
      self.service_name = 'lnrpc.WalletUnlocker'

      # *
      # GenSeed is the first method that should be used to instantiate a new lnd
      # instance. This method allows a caller to generate a new aezeed cipher seed
      # given an optional passphrase. If provided, the passphrase will be necessary
      # to decrypt the cipherseed to expose the internal wallet seed.
      #
      # Once the cipherseed is obtained and verified by the user, the InitWallet
      # method should be used to commit the newly generated seed, and create the
      # wallet.
      rpc :GenSeed, GenSeedRequest, GenSeedResponse
      # *
      # InitWallet is used when lnd is starting up for the first time to fully
      # initialize the daemon and its internal wallet. At the very least a wallet
      # password must be provided. This will be used to encrypt sensitive material
      # on disk.
      #
      # In the case of a recovery scenario, the user can also specify their aezeed
      # mnemonic and passphrase. If set, then the daemon will use this prior state
      # to initialize its internal wallet.
      #
      # Alternatively, this can be used along with the GenSeed RPC to obtain a
      # seed, then present it to the user. Once it has been verified by the user,
      # the seed can be fed into this RPC in order to commit the new wallet.
      rpc :InitWallet, InitWalletRequest, InitWalletResponse
      # * lncli: `unlock`
      # UnlockWallet is used at startup of lnd to provide a password to unlock
      # the wallet database.
      rpc :UnlockWallet, UnlockWalletRequest, UnlockWalletResponse
      # * lncli: `changepassword`
      # ChangePassword changes the password of the encrypted wallet. This will
      # automatically unlock the wallet database if successful.
      rpc :ChangePassword, ChangePasswordRequest, ChangePasswordResponse
    end

    Stub = Service.rpc_stub_class
  end
  module Lightning
    class Service

      include GRPC::GenericService

      self.marshal_class_method = :encode
      self.unmarshal_class_method = :decode
      self.service_name = 'lnrpc.Lightning'

      # * lncli: `walletbalance`
      # WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
      # confirmed unspent outputs and all unconfirmed unspent outputs under control
      # of the wallet.
      rpc :WalletBalance, WalletBalanceRequest, WalletBalanceResponse
      # * lncli: `channelbalance`
      # ChannelBalance returns the total funds available across all open channels
      # in satoshis.
      rpc :ChannelBalance, ChannelBalanceRequest, ChannelBalanceResponse
      # * lncli: `listchaintxns`
      # GetTransactions returns a list describing all the known transactions
      # relevant to the wallet.
      rpc :GetTransactions, GetTransactionsRequest, TransactionDetails
      # * lncli: `sendcoins`
      # SendCoins executes a request to send coins to a particular address. Unlike
      # SendMany, this RPC call only allows creating a single output at a time. If
      # neither target_conf, or sat_per_byte are set, then the internal wallet will
      # consult its fee model to determine a fee for the default confirmation
      # target.
      rpc :SendCoins, SendCoinsRequest, SendCoinsResponse
      # *
      # SubscribeTransactions creates a uni-directional stream from the server to
      # the client in which any newly discovered transactions relevant to the
      # wallet are sent over.
      rpc :SubscribeTransactions, GetTransactionsRequest, stream(Transaction)
      # * lncli: `sendmany`
      # SendMany handles a request for a transaction that creates multiple specified
      # outputs in parallel. If neither target_conf, or sat_per_byte are set, then
      # the internal wallet will consult its fee model to determine a fee for the
      # default confirmation target.
      rpc :SendMany, SendManyRequest, SendManyResponse
      # * lncli: `newaddress`
      # NewAddress creates a new address under control of the local wallet.
      rpc :NewAddress, NewAddressRequest, NewAddressResponse
      # * lncli: `signmessage`
      # SignMessage signs a message with this node's private key. The returned
      # signature string is `zbase32` encoded and pubkey recoverable, meaning that
      # only the message digest and signature are needed for verification.
      rpc :SignMessage, SignMessageRequest, SignMessageResponse
      # * lncli: `verifymessage`
      # VerifyMessage verifies a signature over a msg. The signature must be
      # zbase32 encoded and signed by an active node in the resident node's
      # channel database. In addition to returning the validity of the signature,
      # VerifyMessage also returns the recovered pubkey from the signature.
      rpc :VerifyMessage, VerifyMessageRequest, VerifyMessageResponse
      # * lncli: `connect`
      # ConnectPeer attempts to establish a connection to a remote peer. This is at
      # the networking level, and is used for communication between nodes. This is
      # distinct from establishing a channel with a peer.
      rpc :ConnectPeer, ConnectPeerRequest, ConnectPeerResponse
      # * lncli: `disconnect`
      # DisconnectPeer attempts to disconnect one peer from another identified by a
      # given pubKey. In the case that we currently have a pending or active channel
      # with the target peer, then this action will be not be allowed.
      rpc :DisconnectPeer, DisconnectPeerRequest, DisconnectPeerResponse
      # * lncli: `listpeers`
      # ListPeers returns a verbose listing of all currently active peers.
      rpc :ListPeers, ListPeersRequest, ListPeersResponse
      # * lncli: `getinfo`
      # GetInfo returns general information concerning the lightning node including
      # it's identity pubkey, alias, the chains it is connected to, and information
      # concerning the number of open+pending channels.
      rpc :GetInfo, GetInfoRequest, GetInfoResponse
      # TODO(roasbeef): merge with below with bool?
      #
      # * lncli: `pendingchannels`
      # PendingChannels returns a list of all the channels that are currently
      # considered "pending". A channel is pending if it has finished the funding
      # workflow and is waiting for confirmations for the funding txn, or is in the
      # process of closure, either initiated cooperatively or non-cooperatively.
      rpc :PendingChannels, PendingChannelsRequest, PendingChannelsResponse
      # * lncli: `listchannels`
      # ListChannels returns a description of all the open channels that this node
      # is a participant in.
      rpc :ListChannels, ListChannelsRequest, ListChannelsResponse
      # * lncli: `closedchannels`
      # ClosedChannels returns a description of all the closed channels that
      # this node was a participant in.
      rpc :ClosedChannels, ClosedChannelsRequest, ClosedChannelsResponse
      # *
      # OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
      # call is meant to be consumed by clients to the REST proxy. As with all
      # other sync calls, all byte slices are intended to be populated as hex
      # encoded strings.
      rpc :OpenChannelSync, OpenChannelRequest, ChannelPoint
      # * lncli: `openchannel`
      # OpenChannel attempts to open a singly funded channel specified in the
      # request to a remote peer. Users are able to specify a target number of
      # blocks that the funding transaction should be confirmed in, or a manual fee
      # rate to us for the funding transaction. If neither are specified, then a
      # lax block confirmation target is used.
      rpc :OpenChannel, OpenChannelRequest, stream(OpenStatusUpdate)
      # * lncli: `closechannel`
      # CloseChannel attempts to close an active channel identified by its channel
      # outpoint (ChannelPoint). The actions of this method can additionally be
      # augmented to attempt a force close after a timeout period in the case of an
      # inactive peer. If a non-force close (cooperative closure) is requested,
      # then the user can specify either a target number of blocks until the
      # closure transaction is confirmed, or a manual fee rate. If neither are
      # specified, then a default lax, block confirmation target is used.
      rpc :CloseChannel, CloseChannelRequest, stream(CloseStatusUpdate)
      # * lncli: `abandonchannel`
      # AbandonChannel removes all channel state from the database except for a
      # close summary. This method can be used to get rid of permanently unusable
      # channels due to bugs fixed in newer versions of lnd. Only available
      # when in debug builds of lnd.
      rpc :AbandonChannel, AbandonChannelRequest, AbandonChannelResponse
      # * lncli: `sendpayment`
      # SendPayment dispatches a bi-directional streaming RPC for sending payments
      # through the Lightning Network. A single RPC invocation creates a persistent
      # bi-directional stream allowing clients to rapidly send payments through the
      # Lightning Network with a single persistent connection.
      rpc :SendPayment, stream(SendRequest), stream(SendResponse)
      # *
      # SendPaymentSync is the synchronous non-streaming version of SendPayment.
      # This RPC is intended to be consumed by clients of the REST proxy.
      # Additionally, this RPC expects the destination's public key and the payment
      # hash (if any) to be encoded as hex strings.
      rpc :SendPaymentSync, SendRequest, SendResponse
      # * lncli: `sendtoroute`
      # SendToRoute is a bi-directional streaming RPC for sending payment through
      # the Lightning Network. This method differs from SendPayment in that it
      # allows users to specify a full route manually. This can be used for things
      # like rebalancing, and atomic swaps.
      rpc :SendToRoute, stream(SendToRouteRequest), stream(SendResponse)
      # *
      # SendToRouteSync is a synchronous version of SendToRoute. It Will block
      # until the payment either fails or succeeds.
      rpc :SendToRouteSync, SendToRouteRequest, SendResponse
      # * lncli: `addinvoice`
      # AddInvoice attempts to add a new invoice to the invoice database. Any
      # duplicated invoices are rejected, therefore all invoices *must* have a
      # unique payment preimage.
      rpc :AddInvoice, Invoice, AddInvoiceResponse
      # * lncli: `listinvoices`
      # ListInvoices returns a list of all the invoices currently stored within the
      # database. Any active debug invoices are ignored. It has full support for
      # paginated responses, allowing users to query for specific invoices through
      # their add_index. This can be done by using either the first_index_offset or
      # last_index_offset fields included in the response as the index_offset of the
      # next request. The reversed flag is set by default in order to paginate
      # backwards. If you wish to paginate forwards, you must explicitly set the
      # flag to false. If none of the parameters are specified, then the last 100
      # invoices will be returned.
      rpc :ListInvoices, ListInvoiceRequest, ListInvoiceResponse
      # * lncli: `lookupinvoice`
      # LookupInvoice attempts to look up an invoice according to its payment hash.
      # The passed payment hash *must* be exactly 32 bytes, if not, an error is
      # returned.
      rpc :LookupInvoice, PaymentHash, Invoice
      # *
      # SubscribeInvoices returns a uni-directional stream (server -> client) for
      # notifying the client of newly added/settled invoices. The caller can
      # optionally specify the add_index and/or the settle_index. If the add_index
      # is specified, then we'll first start by sending add invoice events for all
      # invoices with an add_index greater than the specified value.  If the
      # settle_index is specified, the next, we'll send out all settle events for
      # invoices with a settle_index greater than the specified value.  One or both
      # of these fields can be set. If no fields are set, then we'll only send out
      # the latest add/settle events.
      rpc :SubscribeInvoices, InvoiceSubscription, stream(Invoice)
      # * lncli: `decodepayreq`
      # DecodePayReq takes an encoded payment request string and attempts to decode
      # it, returning a full description of the conditions encoded within the
      # payment request.
      rpc :DecodePayReq, PayReqString, PayReq
      # * lncli: `listpayments`
      # ListPayments returns a list of all outgoing payments.
      rpc :ListPayments, ListPaymentsRequest, ListPaymentsResponse
      # *
      # DeleteAllPayments deletes all outgoing payments from DB.
      rpc :DeleteAllPayments, DeleteAllPaymentsRequest, DeleteAllPaymentsResponse
      # * lncli: `describegraph`
      # DescribeGraph returns a description of the latest graph state from the
      # point of view of the node. The graph information is partitioned into two
      # components: all the nodes/vertexes, and all the edges that connect the
      # vertexes themselves.  As this is a directed graph, the edges also contain
      # the node directional specific routing policy which includes: the time lock
      # delta, fee information, etc.
      rpc :DescribeGraph, ChannelGraphRequest, ChannelGraph
      # * lncli: `getchaninfo`
      # GetChanInfo returns the latest authenticated network announcement for the
      # given channel identified by its channel ID: an 8-byte integer which
      # uniquely identifies the location of transaction's funding output within the
      # blockchain.
      rpc :GetChanInfo, ChanInfoRequest, ChannelEdge
      # * lncli: `getnodeinfo`
      # GetNodeInfo returns the latest advertised, aggregated, and authenticated
      # channel information for the specified node identified by its public key.
      rpc :GetNodeInfo, NodeInfoRequest, NodeInfo
      # * lncli: `queryroutes`
      # QueryRoutes attempts to query the daemon's Channel Router for a possible
      # route to a target destination capable of carrying a specific amount of
      # satoshis. The retuned route contains the full details required to craft and
      # send an HTLC, also including the necessary information that should be
      # present within the Sphinx packet encapsulated within the HTLC.
      rpc :QueryRoutes, QueryRoutesRequest, QueryRoutesResponse
      # * lncli: `getnetworkinfo`
      # GetNetworkInfo returns some basic stats about the known channel graph from
      # the point of view of the node.
      rpc :GetNetworkInfo, NetworkInfoRequest, NetworkInfo
      # * lncli: `stop`
      # StopDaemon will send a shutdown request to the interrupt handler, triggering
      # a graceful shutdown of the daemon.
      rpc :StopDaemon, StopRequest, StopResponse
      # *
      # SubscribeChannelGraph launches a streaming RPC that allows the caller to
      # receive notifications upon any changes to the channel graph topology from
      # the point of view of the responding node. Events notified include: new
      # nodes coming online, nodes updating their authenticated attributes, new
      # channels being advertised, updates in the routing policy for a directional
      # channel edge, and when channels are closed on-chain.
      rpc :SubscribeChannelGraph, GraphTopologySubscription, stream(GraphTopologyUpdate)
      # * lncli: `debuglevel`
      # DebugLevel allows a caller to programmatically set the logging verbosity of
      # lnd. The logging can be targeted according to a coarse daemon-wide logging
      # level, or in a granular fashion to specify the logging for a target
      # sub-system.
      rpc :DebugLevel, DebugLevelRequest, DebugLevelResponse
      # * lncli: `feereport`
      # FeeReport allows the caller to obtain a report detailing the current fee
      # schedule enforced by the node globally for each channel.
      rpc :FeeReport, FeeReportRequest, FeeReportResponse
      # * lncli: `updatechanpolicy`
      # UpdateChannelPolicy allows the caller to update the fee schedule and
      # channel policies for all channels globally, or a particular channel.
      rpc :UpdateChannelPolicy, PolicyUpdateRequest, PolicyUpdateResponse
      # * lncli: `fwdinghistory`
      # ForwardingHistory allows the caller to query the htlcswitch for a record of
      # all HTLC's forwarded within the target time range, and integer offset
      # within that time range. If no time-range is specified, then the first chunk
      # of the past 24 hrs of forwarding history are returned.
      #
      # A list of forwarding events are returned. The size of each forwarding event
      # is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
      # As a result each message can only contain 50k entries.  Each response has
      # the index offset of the last entry. The index offset can be provided to the
      # request to allow the caller to skip a series of records.
      rpc :ForwardingHistory, ForwardingHistoryRequest, ForwardingHistoryResponse
    end

    Stub = Service.rpc_stub_class
  end
end
